// Code generated by counterfeiter. DO NOT EDIT.
package csi_fake

import (
	"sync"

	"github.com/container-storage-interface/spec/lib/go/csi"
	"golang.org/x/net/context"
	"google.golang.org/grpc"
)

type FakeIdentityClient struct {
	GetSupportedVersionsStub        func(ctx context.Context, in *csi.GetSupportedVersionsRequest, opts ...grpc.CallOption) (*csi.GetSupportedVersionsResponse, error)
	getSupportedVersionsMutex       sync.RWMutex
	getSupportedVersionsArgsForCall []struct {
		ctx  context.Context
		in   *csi.GetSupportedVersionsRequest
		opts []grpc.CallOption
	}
	getSupportedVersionsReturns struct {
		result1 *csi.GetSupportedVersionsResponse
		result2 error
	}
	getSupportedVersionsReturnsOnCall map[int]struct {
		result1 *csi.GetSupportedVersionsResponse
		result2 error
	}
	GetPluginInfoStub        func(ctx context.Context, in *csi.GetPluginInfoRequest, opts ...grpc.CallOption) (*csi.GetPluginInfoResponse, error)
	getPluginInfoMutex       sync.RWMutex
	getPluginInfoArgsForCall []struct {
		ctx  context.Context
		in   *csi.GetPluginInfoRequest
		opts []grpc.CallOption
	}
	getPluginInfoReturns struct {
		result1 *csi.GetPluginInfoResponse
		result2 error
	}
	getPluginInfoReturnsOnCall map[int]struct {
		result1 *csi.GetPluginInfoResponse
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeIdentityClient) GetSupportedVersions(ctx context.Context, in *csi.GetSupportedVersionsRequest, opts ...grpc.CallOption) (*csi.GetSupportedVersionsResponse, error) {
	fake.getSupportedVersionsMutex.Lock()
	ret, specificReturn := fake.getSupportedVersionsReturnsOnCall[len(fake.getSupportedVersionsArgsForCall)]
	fake.getSupportedVersionsArgsForCall = append(fake.getSupportedVersionsArgsForCall, struct {
		ctx  context.Context
		in   *csi.GetSupportedVersionsRequest
		opts []grpc.CallOption
	}{ctx, in, opts})
	fake.recordInvocation("GetSupportedVersions", []interface{}{ctx, in, opts})
	fake.getSupportedVersionsMutex.Unlock()
	if fake.GetSupportedVersionsStub != nil {
		return fake.GetSupportedVersionsStub(ctx, in, opts...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getSupportedVersionsReturns.result1, fake.getSupportedVersionsReturns.result2
}

func (fake *FakeIdentityClient) GetSupportedVersionsCallCount() int {
	fake.getSupportedVersionsMutex.RLock()
	defer fake.getSupportedVersionsMutex.RUnlock()
	return len(fake.getSupportedVersionsArgsForCall)
}

func (fake *FakeIdentityClient) GetSupportedVersionsArgsForCall(i int) (context.Context, *csi.GetSupportedVersionsRequest, []grpc.CallOption) {
	fake.getSupportedVersionsMutex.RLock()
	defer fake.getSupportedVersionsMutex.RUnlock()
	return fake.getSupportedVersionsArgsForCall[i].ctx, fake.getSupportedVersionsArgsForCall[i].in, fake.getSupportedVersionsArgsForCall[i].opts
}

func (fake *FakeIdentityClient) GetSupportedVersionsReturns(result1 *csi.GetSupportedVersionsResponse, result2 error) {
	fake.GetSupportedVersionsStub = nil
	fake.getSupportedVersionsReturns = struct {
		result1 *csi.GetSupportedVersionsResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeIdentityClient) GetSupportedVersionsReturnsOnCall(i int, result1 *csi.GetSupportedVersionsResponse, result2 error) {
	fake.GetSupportedVersionsStub = nil
	if fake.getSupportedVersionsReturnsOnCall == nil {
		fake.getSupportedVersionsReturnsOnCall = make(map[int]struct {
			result1 *csi.GetSupportedVersionsResponse
			result2 error
		})
	}
	fake.getSupportedVersionsReturnsOnCall[i] = struct {
		result1 *csi.GetSupportedVersionsResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeIdentityClient) GetPluginInfo(ctx context.Context, in *csi.GetPluginInfoRequest, opts ...grpc.CallOption) (*csi.GetPluginInfoResponse, error) {
	fake.getPluginInfoMutex.Lock()
	ret, specificReturn := fake.getPluginInfoReturnsOnCall[len(fake.getPluginInfoArgsForCall)]
	fake.getPluginInfoArgsForCall = append(fake.getPluginInfoArgsForCall, struct {
		ctx  context.Context
		in   *csi.GetPluginInfoRequest
		opts []grpc.CallOption
	}{ctx, in, opts})
	fake.recordInvocation("GetPluginInfo", []interface{}{ctx, in, opts})
	fake.getPluginInfoMutex.Unlock()
	if fake.GetPluginInfoStub != nil {
		return fake.GetPluginInfoStub(ctx, in, opts...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getPluginInfoReturns.result1, fake.getPluginInfoReturns.result2
}

func (fake *FakeIdentityClient) GetPluginInfoCallCount() int {
	fake.getPluginInfoMutex.RLock()
	defer fake.getPluginInfoMutex.RUnlock()
	return len(fake.getPluginInfoArgsForCall)
}

func (fake *FakeIdentityClient) GetPluginInfoArgsForCall(i int) (context.Context, *csi.GetPluginInfoRequest, []grpc.CallOption) {
	fake.getPluginInfoMutex.RLock()
	defer fake.getPluginInfoMutex.RUnlock()
	return fake.getPluginInfoArgsForCall[i].ctx, fake.getPluginInfoArgsForCall[i].in, fake.getPluginInfoArgsForCall[i].opts
}

func (fake *FakeIdentityClient) GetPluginInfoReturns(result1 *csi.GetPluginInfoResponse, result2 error) {
	fake.GetPluginInfoStub = nil
	fake.getPluginInfoReturns = struct {
		result1 *csi.GetPluginInfoResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeIdentityClient) GetPluginInfoReturnsOnCall(i int, result1 *csi.GetPluginInfoResponse, result2 error) {
	fake.GetPluginInfoStub = nil
	if fake.getPluginInfoReturnsOnCall == nil {
		fake.getPluginInfoReturnsOnCall = make(map[int]struct {
			result1 *csi.GetPluginInfoResponse
			result2 error
		})
	}
	fake.getPluginInfoReturnsOnCall[i] = struct {
		result1 *csi.GetPluginInfoResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeIdentityClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.getSupportedVersionsMutex.RLock()
	defer fake.getSupportedVersionsMutex.RUnlock()
	fake.getPluginInfoMutex.RLock()
	defer fake.getPluginInfoMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeIdentityClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ csi.IdentityClient = new(FakeIdentityClient)
