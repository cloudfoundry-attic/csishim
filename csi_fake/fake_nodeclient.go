// Code generated by counterfeiter. DO NOT EDIT.
package csi_fake

import (
	"sync"

	csi "github.com/container-storage-interface/spec/lib/go/csi/v0"
	"golang.org/x/net/context"
	"google.golang.org/grpc"
)

type FakeNodeClient struct {
	NodeStageVolumeStub        func(ctx context.Context, in *csi.NodeStageVolumeRequest, opts ...grpc.CallOption) (*csi.NodeStageVolumeResponse, error)
	nodeStageVolumeMutex       sync.RWMutex
	nodeStageVolumeArgsForCall []struct {
		ctx  context.Context
		in   *csi.NodeStageVolumeRequest
		opts []grpc.CallOption
	}
	nodeStageVolumeReturns struct {
		result1 *csi.NodeStageVolumeResponse
		result2 error
	}
	nodeStageVolumeReturnsOnCall map[int]struct {
		result1 *csi.NodeStageVolumeResponse
		result2 error
	}
	NodeUnstageVolumeStub        func(ctx context.Context, in *csi.NodeUnstageVolumeRequest, opts ...grpc.CallOption) (*csi.NodeUnstageVolumeResponse, error)
	nodeUnstageVolumeMutex       sync.RWMutex
	nodeUnstageVolumeArgsForCall []struct {
		ctx  context.Context
		in   *csi.NodeUnstageVolumeRequest
		opts []grpc.CallOption
	}
	nodeUnstageVolumeReturns struct {
		result1 *csi.NodeUnstageVolumeResponse
		result2 error
	}
	nodeUnstageVolumeReturnsOnCall map[int]struct {
		result1 *csi.NodeUnstageVolumeResponse
		result2 error
	}
	NodePublishVolumeStub        func(ctx context.Context, in *csi.NodePublishVolumeRequest, opts ...grpc.CallOption) (*csi.NodePublishVolumeResponse, error)
	nodePublishVolumeMutex       sync.RWMutex
	nodePublishVolumeArgsForCall []struct {
		ctx  context.Context
		in   *csi.NodePublishVolumeRequest
		opts []grpc.CallOption
	}
	nodePublishVolumeReturns struct {
		result1 *csi.NodePublishVolumeResponse
		result2 error
	}
	nodePublishVolumeReturnsOnCall map[int]struct {
		result1 *csi.NodePublishVolumeResponse
		result2 error
	}
	NodeUnpublishVolumeStub        func(ctx context.Context, in *csi.NodeUnpublishVolumeRequest, opts ...grpc.CallOption) (*csi.NodeUnpublishVolumeResponse, error)
	nodeUnpublishVolumeMutex       sync.RWMutex
	nodeUnpublishVolumeArgsForCall []struct {
		ctx  context.Context
		in   *csi.NodeUnpublishVolumeRequest
		opts []grpc.CallOption
	}
	nodeUnpublishVolumeReturns struct {
		result1 *csi.NodeUnpublishVolumeResponse
		result2 error
	}
	nodeUnpublishVolumeReturnsOnCall map[int]struct {
		result1 *csi.NodeUnpublishVolumeResponse
		result2 error
	}
	NodeGetIdStub        func(ctx context.Context, in *csi.NodeGetIdRequest, opts ...grpc.CallOption) (*csi.NodeGetIdResponse, error)
	nodeGetIdMutex       sync.RWMutex
	nodeGetIdArgsForCall []struct {
		ctx  context.Context
		in   *csi.NodeGetIdRequest
		opts []grpc.CallOption
	}
	nodeGetIdReturns struct {
		result1 *csi.NodeGetIdResponse
		result2 error
	}
	nodeGetIdReturnsOnCall map[int]struct {
		result1 *csi.NodeGetIdResponse
		result2 error
	}
	NodeGetCapabilitiesStub        func(ctx context.Context, in *csi.NodeGetCapabilitiesRequest, opts ...grpc.CallOption) (*csi.NodeGetCapabilitiesResponse, error)
	nodeGetCapabilitiesMutex       sync.RWMutex
	nodeGetCapabilitiesArgsForCall []struct {
		ctx  context.Context
		in   *csi.NodeGetCapabilitiesRequest
		opts []grpc.CallOption
	}
	nodeGetCapabilitiesReturns struct {
		result1 *csi.NodeGetCapabilitiesResponse
		result2 error
	}
	nodeGetCapabilitiesReturnsOnCall map[int]struct {
		result1 *csi.NodeGetCapabilitiesResponse
		result2 error
	}
	NodeGetInfoStub        func(ctx context.Context, in *csi.NodeGetInfoRequest, opts ...grpc.CallOption) (*csi.NodeGetInfoResponse, error)
	nodeGetInfoMutex       sync.RWMutex
	nodeGetInfoArgsForCall []struct {
		ctx  context.Context
		in   *csi.NodeGetInfoRequest
		opts []grpc.CallOption
	}
	nodeGetInfoReturns struct {
		result1 *csi.NodeGetInfoResponse
		result2 error
	}
	nodeGetInfoReturnsOnCall map[int]struct {
		result1 *csi.NodeGetInfoResponse
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeNodeClient) NodeStageVolume(ctx context.Context, in *csi.NodeStageVolumeRequest, opts ...grpc.CallOption) (*csi.NodeStageVolumeResponse, error) {
	fake.nodeStageVolumeMutex.Lock()
	ret, specificReturn := fake.nodeStageVolumeReturnsOnCall[len(fake.nodeStageVolumeArgsForCall)]
	fake.nodeStageVolumeArgsForCall = append(fake.nodeStageVolumeArgsForCall, struct {
		ctx  context.Context
		in   *csi.NodeStageVolumeRequest
		opts []grpc.CallOption
	}{ctx, in, opts})
	fake.recordInvocation("NodeStageVolume", []interface{}{ctx, in, opts})
	fake.nodeStageVolumeMutex.Unlock()
	if fake.NodeStageVolumeStub != nil {
		return fake.NodeStageVolumeStub(ctx, in, opts...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.nodeStageVolumeReturns.result1, fake.nodeStageVolumeReturns.result2
}

func (fake *FakeNodeClient) NodeStageVolumeCallCount() int {
	fake.nodeStageVolumeMutex.RLock()
	defer fake.nodeStageVolumeMutex.RUnlock()
	return len(fake.nodeStageVolumeArgsForCall)
}

func (fake *FakeNodeClient) NodeStageVolumeArgsForCall(i int) (context.Context, *csi.NodeStageVolumeRequest, []grpc.CallOption) {
	fake.nodeStageVolumeMutex.RLock()
	defer fake.nodeStageVolumeMutex.RUnlock()
	return fake.nodeStageVolumeArgsForCall[i].ctx, fake.nodeStageVolumeArgsForCall[i].in, fake.nodeStageVolumeArgsForCall[i].opts
}

func (fake *FakeNodeClient) NodeStageVolumeReturns(result1 *csi.NodeStageVolumeResponse, result2 error) {
	fake.NodeStageVolumeStub = nil
	fake.nodeStageVolumeReturns = struct {
		result1 *csi.NodeStageVolumeResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeNodeClient) NodeStageVolumeReturnsOnCall(i int, result1 *csi.NodeStageVolumeResponse, result2 error) {
	fake.NodeStageVolumeStub = nil
	if fake.nodeStageVolumeReturnsOnCall == nil {
		fake.nodeStageVolumeReturnsOnCall = make(map[int]struct {
			result1 *csi.NodeStageVolumeResponse
			result2 error
		})
	}
	fake.nodeStageVolumeReturnsOnCall[i] = struct {
		result1 *csi.NodeStageVolumeResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeNodeClient) NodeUnstageVolume(ctx context.Context, in *csi.NodeUnstageVolumeRequest, opts ...grpc.CallOption) (*csi.NodeUnstageVolumeResponse, error) {
	fake.nodeUnstageVolumeMutex.Lock()
	ret, specificReturn := fake.nodeUnstageVolumeReturnsOnCall[len(fake.nodeUnstageVolumeArgsForCall)]
	fake.nodeUnstageVolumeArgsForCall = append(fake.nodeUnstageVolumeArgsForCall, struct {
		ctx  context.Context
		in   *csi.NodeUnstageVolumeRequest
		opts []grpc.CallOption
	}{ctx, in, opts})
	fake.recordInvocation("NodeUnstageVolume", []interface{}{ctx, in, opts})
	fake.nodeUnstageVolumeMutex.Unlock()
	if fake.NodeUnstageVolumeStub != nil {
		return fake.NodeUnstageVolumeStub(ctx, in, opts...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.nodeUnstageVolumeReturns.result1, fake.nodeUnstageVolumeReturns.result2
}

func (fake *FakeNodeClient) NodeUnstageVolumeCallCount() int {
	fake.nodeUnstageVolumeMutex.RLock()
	defer fake.nodeUnstageVolumeMutex.RUnlock()
	return len(fake.nodeUnstageVolumeArgsForCall)
}

func (fake *FakeNodeClient) NodeUnstageVolumeArgsForCall(i int) (context.Context, *csi.NodeUnstageVolumeRequest, []grpc.CallOption) {
	fake.nodeUnstageVolumeMutex.RLock()
	defer fake.nodeUnstageVolumeMutex.RUnlock()
	return fake.nodeUnstageVolumeArgsForCall[i].ctx, fake.nodeUnstageVolumeArgsForCall[i].in, fake.nodeUnstageVolumeArgsForCall[i].opts
}

func (fake *FakeNodeClient) NodeUnstageVolumeReturns(result1 *csi.NodeUnstageVolumeResponse, result2 error) {
	fake.NodeUnstageVolumeStub = nil
	fake.nodeUnstageVolumeReturns = struct {
		result1 *csi.NodeUnstageVolumeResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeNodeClient) NodeUnstageVolumeReturnsOnCall(i int, result1 *csi.NodeUnstageVolumeResponse, result2 error) {
	fake.NodeUnstageVolumeStub = nil
	if fake.nodeUnstageVolumeReturnsOnCall == nil {
		fake.nodeUnstageVolumeReturnsOnCall = make(map[int]struct {
			result1 *csi.NodeUnstageVolumeResponse
			result2 error
		})
	}
	fake.nodeUnstageVolumeReturnsOnCall[i] = struct {
		result1 *csi.NodeUnstageVolumeResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeNodeClient) NodePublishVolume(ctx context.Context, in *csi.NodePublishVolumeRequest, opts ...grpc.CallOption) (*csi.NodePublishVolumeResponse, error) {
	fake.nodePublishVolumeMutex.Lock()
	ret, specificReturn := fake.nodePublishVolumeReturnsOnCall[len(fake.nodePublishVolumeArgsForCall)]
	fake.nodePublishVolumeArgsForCall = append(fake.nodePublishVolumeArgsForCall, struct {
		ctx  context.Context
		in   *csi.NodePublishVolumeRequest
		opts []grpc.CallOption
	}{ctx, in, opts})
	fake.recordInvocation("NodePublishVolume", []interface{}{ctx, in, opts})
	fake.nodePublishVolumeMutex.Unlock()
	if fake.NodePublishVolumeStub != nil {
		return fake.NodePublishVolumeStub(ctx, in, opts...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.nodePublishVolumeReturns.result1, fake.nodePublishVolumeReturns.result2
}

func (fake *FakeNodeClient) NodePublishVolumeCallCount() int {
	fake.nodePublishVolumeMutex.RLock()
	defer fake.nodePublishVolumeMutex.RUnlock()
	return len(fake.nodePublishVolumeArgsForCall)
}

func (fake *FakeNodeClient) NodePublishVolumeArgsForCall(i int) (context.Context, *csi.NodePublishVolumeRequest, []grpc.CallOption) {
	fake.nodePublishVolumeMutex.RLock()
	defer fake.nodePublishVolumeMutex.RUnlock()
	return fake.nodePublishVolumeArgsForCall[i].ctx, fake.nodePublishVolumeArgsForCall[i].in, fake.nodePublishVolumeArgsForCall[i].opts
}

func (fake *FakeNodeClient) NodePublishVolumeReturns(result1 *csi.NodePublishVolumeResponse, result2 error) {
	fake.NodePublishVolumeStub = nil
	fake.nodePublishVolumeReturns = struct {
		result1 *csi.NodePublishVolumeResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeNodeClient) NodePublishVolumeReturnsOnCall(i int, result1 *csi.NodePublishVolumeResponse, result2 error) {
	fake.NodePublishVolumeStub = nil
	if fake.nodePublishVolumeReturnsOnCall == nil {
		fake.nodePublishVolumeReturnsOnCall = make(map[int]struct {
			result1 *csi.NodePublishVolumeResponse
			result2 error
		})
	}
	fake.nodePublishVolumeReturnsOnCall[i] = struct {
		result1 *csi.NodePublishVolumeResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeNodeClient) NodeUnpublishVolume(ctx context.Context, in *csi.NodeUnpublishVolumeRequest, opts ...grpc.CallOption) (*csi.NodeUnpublishVolumeResponse, error) {
	fake.nodeUnpublishVolumeMutex.Lock()
	ret, specificReturn := fake.nodeUnpublishVolumeReturnsOnCall[len(fake.nodeUnpublishVolumeArgsForCall)]
	fake.nodeUnpublishVolumeArgsForCall = append(fake.nodeUnpublishVolumeArgsForCall, struct {
		ctx  context.Context
		in   *csi.NodeUnpublishVolumeRequest
		opts []grpc.CallOption
	}{ctx, in, opts})
	fake.recordInvocation("NodeUnpublishVolume", []interface{}{ctx, in, opts})
	fake.nodeUnpublishVolumeMutex.Unlock()
	if fake.NodeUnpublishVolumeStub != nil {
		return fake.NodeUnpublishVolumeStub(ctx, in, opts...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.nodeUnpublishVolumeReturns.result1, fake.nodeUnpublishVolumeReturns.result2
}

func (fake *FakeNodeClient) NodeUnpublishVolumeCallCount() int {
	fake.nodeUnpublishVolumeMutex.RLock()
	defer fake.nodeUnpublishVolumeMutex.RUnlock()
	return len(fake.nodeUnpublishVolumeArgsForCall)
}

func (fake *FakeNodeClient) NodeUnpublishVolumeArgsForCall(i int) (context.Context, *csi.NodeUnpublishVolumeRequest, []grpc.CallOption) {
	fake.nodeUnpublishVolumeMutex.RLock()
	defer fake.nodeUnpublishVolumeMutex.RUnlock()
	return fake.nodeUnpublishVolumeArgsForCall[i].ctx, fake.nodeUnpublishVolumeArgsForCall[i].in, fake.nodeUnpublishVolumeArgsForCall[i].opts
}

func (fake *FakeNodeClient) NodeUnpublishVolumeReturns(result1 *csi.NodeUnpublishVolumeResponse, result2 error) {
	fake.NodeUnpublishVolumeStub = nil
	fake.nodeUnpublishVolumeReturns = struct {
		result1 *csi.NodeUnpublishVolumeResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeNodeClient) NodeUnpublishVolumeReturnsOnCall(i int, result1 *csi.NodeUnpublishVolumeResponse, result2 error) {
	fake.NodeUnpublishVolumeStub = nil
	if fake.nodeUnpublishVolumeReturnsOnCall == nil {
		fake.nodeUnpublishVolumeReturnsOnCall = make(map[int]struct {
			result1 *csi.NodeUnpublishVolumeResponse
			result2 error
		})
	}
	fake.nodeUnpublishVolumeReturnsOnCall[i] = struct {
		result1 *csi.NodeUnpublishVolumeResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeNodeClient) NodeGetId(ctx context.Context, in *csi.NodeGetIdRequest, opts ...grpc.CallOption) (*csi.NodeGetIdResponse, error) {
	fake.nodeGetIdMutex.Lock()
	ret, specificReturn := fake.nodeGetIdReturnsOnCall[len(fake.nodeGetIdArgsForCall)]
	fake.nodeGetIdArgsForCall = append(fake.nodeGetIdArgsForCall, struct {
		ctx  context.Context
		in   *csi.NodeGetIdRequest
		opts []grpc.CallOption
	}{ctx, in, opts})
	fake.recordInvocation("NodeGetId", []interface{}{ctx, in, opts})
	fake.nodeGetIdMutex.Unlock()
	if fake.NodeGetIdStub != nil {
		return fake.NodeGetIdStub(ctx, in, opts...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.nodeGetIdReturns.result1, fake.nodeGetIdReturns.result2
}

func (fake *FakeNodeClient) NodeGetIdCallCount() int {
	fake.nodeGetIdMutex.RLock()
	defer fake.nodeGetIdMutex.RUnlock()
	return len(fake.nodeGetIdArgsForCall)
}

func (fake *FakeNodeClient) NodeGetIdArgsForCall(i int) (context.Context, *csi.NodeGetIdRequest, []grpc.CallOption) {
	fake.nodeGetIdMutex.RLock()
	defer fake.nodeGetIdMutex.RUnlock()
	return fake.nodeGetIdArgsForCall[i].ctx, fake.nodeGetIdArgsForCall[i].in, fake.nodeGetIdArgsForCall[i].opts
}

func (fake *FakeNodeClient) NodeGetIdReturns(result1 *csi.NodeGetIdResponse, result2 error) {
	fake.NodeGetIdStub = nil
	fake.nodeGetIdReturns = struct {
		result1 *csi.NodeGetIdResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeNodeClient) NodeGetIdReturnsOnCall(i int, result1 *csi.NodeGetIdResponse, result2 error) {
	fake.NodeGetIdStub = nil
	if fake.nodeGetIdReturnsOnCall == nil {
		fake.nodeGetIdReturnsOnCall = make(map[int]struct {
			result1 *csi.NodeGetIdResponse
			result2 error
		})
	}
	fake.nodeGetIdReturnsOnCall[i] = struct {
		result1 *csi.NodeGetIdResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeNodeClient) NodeGetCapabilities(ctx context.Context, in *csi.NodeGetCapabilitiesRequest, opts ...grpc.CallOption) (*csi.NodeGetCapabilitiesResponse, error) {
	fake.nodeGetCapabilitiesMutex.Lock()
	ret, specificReturn := fake.nodeGetCapabilitiesReturnsOnCall[len(fake.nodeGetCapabilitiesArgsForCall)]
	fake.nodeGetCapabilitiesArgsForCall = append(fake.nodeGetCapabilitiesArgsForCall, struct {
		ctx  context.Context
		in   *csi.NodeGetCapabilitiesRequest
		opts []grpc.CallOption
	}{ctx, in, opts})
	fake.recordInvocation("NodeGetCapabilities", []interface{}{ctx, in, opts})
	fake.nodeGetCapabilitiesMutex.Unlock()
	if fake.NodeGetCapabilitiesStub != nil {
		return fake.NodeGetCapabilitiesStub(ctx, in, opts...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.nodeGetCapabilitiesReturns.result1, fake.nodeGetCapabilitiesReturns.result2
}

func (fake *FakeNodeClient) NodeGetCapabilitiesCallCount() int {
	fake.nodeGetCapabilitiesMutex.RLock()
	defer fake.nodeGetCapabilitiesMutex.RUnlock()
	return len(fake.nodeGetCapabilitiesArgsForCall)
}

func (fake *FakeNodeClient) NodeGetCapabilitiesArgsForCall(i int) (context.Context, *csi.NodeGetCapabilitiesRequest, []grpc.CallOption) {
	fake.nodeGetCapabilitiesMutex.RLock()
	defer fake.nodeGetCapabilitiesMutex.RUnlock()
	return fake.nodeGetCapabilitiesArgsForCall[i].ctx, fake.nodeGetCapabilitiesArgsForCall[i].in, fake.nodeGetCapabilitiesArgsForCall[i].opts
}

func (fake *FakeNodeClient) NodeGetCapabilitiesReturns(result1 *csi.NodeGetCapabilitiesResponse, result2 error) {
	fake.NodeGetCapabilitiesStub = nil
	fake.nodeGetCapabilitiesReturns = struct {
		result1 *csi.NodeGetCapabilitiesResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeNodeClient) NodeGetCapabilitiesReturnsOnCall(i int, result1 *csi.NodeGetCapabilitiesResponse, result2 error) {
	fake.NodeGetCapabilitiesStub = nil
	if fake.nodeGetCapabilitiesReturnsOnCall == nil {
		fake.nodeGetCapabilitiesReturnsOnCall = make(map[int]struct {
			result1 *csi.NodeGetCapabilitiesResponse
			result2 error
		})
	}
	fake.nodeGetCapabilitiesReturnsOnCall[i] = struct {
		result1 *csi.NodeGetCapabilitiesResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeNodeClient) NodeGetInfo(ctx context.Context, in *csi.NodeGetInfoRequest, opts ...grpc.CallOption) (*csi.NodeGetInfoResponse, error) {
	fake.nodeGetInfoMutex.Lock()
	ret, specificReturn := fake.nodeGetInfoReturnsOnCall[len(fake.nodeGetInfoArgsForCall)]
	fake.nodeGetInfoArgsForCall = append(fake.nodeGetInfoArgsForCall, struct {
		ctx  context.Context
		in   *csi.NodeGetInfoRequest
		opts []grpc.CallOption
	}{ctx, in, opts})
	fake.recordInvocation("NodeGetInfo", []interface{}{ctx, in, opts})
	fake.nodeGetInfoMutex.Unlock()
	if fake.NodeGetInfoStub != nil {
		return fake.NodeGetInfoStub(ctx, in, opts...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.nodeGetInfoReturns.result1, fake.nodeGetInfoReturns.result2
}

func (fake *FakeNodeClient) NodeGetInfoCallCount() int {
	fake.nodeGetInfoMutex.RLock()
	defer fake.nodeGetInfoMutex.RUnlock()
	return len(fake.nodeGetInfoArgsForCall)
}

func (fake *FakeNodeClient) NodeGetInfoArgsForCall(i int) (context.Context, *csi.NodeGetInfoRequest, []grpc.CallOption) {
	fake.nodeGetInfoMutex.RLock()
	defer fake.nodeGetInfoMutex.RUnlock()
	return fake.nodeGetInfoArgsForCall[i].ctx, fake.nodeGetInfoArgsForCall[i].in, fake.nodeGetInfoArgsForCall[i].opts
}

func (fake *FakeNodeClient) NodeGetInfoReturns(result1 *csi.NodeGetInfoResponse, result2 error) {
	fake.NodeGetInfoStub = nil
	fake.nodeGetInfoReturns = struct {
		result1 *csi.NodeGetInfoResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeNodeClient) NodeGetInfoReturnsOnCall(i int, result1 *csi.NodeGetInfoResponse, result2 error) {
	fake.NodeGetInfoStub = nil
	if fake.nodeGetInfoReturnsOnCall == nil {
		fake.nodeGetInfoReturnsOnCall = make(map[int]struct {
			result1 *csi.NodeGetInfoResponse
			result2 error
		})
	}
	fake.nodeGetInfoReturnsOnCall[i] = struct {
		result1 *csi.NodeGetInfoResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeNodeClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.nodeStageVolumeMutex.RLock()
	defer fake.nodeStageVolumeMutex.RUnlock()
	fake.nodeUnstageVolumeMutex.RLock()
	defer fake.nodeUnstageVolumeMutex.RUnlock()
	fake.nodePublishVolumeMutex.RLock()
	defer fake.nodePublishVolumeMutex.RUnlock()
	fake.nodeUnpublishVolumeMutex.RLock()
	defer fake.nodeUnpublishVolumeMutex.RUnlock()
	fake.nodeGetIdMutex.RLock()
	defer fake.nodeGetIdMutex.RUnlock()
	fake.nodeGetCapabilitiesMutex.RLock()
	defer fake.nodeGetCapabilitiesMutex.RUnlock()
	fake.nodeGetInfoMutex.RLock()
	defer fake.nodeGetInfoMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeNodeClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ csi.NodeClient = new(FakeNodeClient)
